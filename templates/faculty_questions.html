<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Question with Modal Whiteboard</title>
  <script>
window.MathJax = {
  tex: { inlineMath: [['$', '$'], ['\\(', '\\)'], ['\\[', '\\]']], displayMath: [['$$','$$']] },
  svg: { fontCache: 'global' }
};
</script>
<!-- MathJax for LaTeX rendering -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async 
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- MathJax for LaTeX rendering -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async 
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 20px;
      background: #f0f2f5;
    }
        .navbar {
      background-color: #007B5E;
      padding: 15px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
    }

    .navbar h1 {
      margin: 0;
      font-size: 22px;
    }

    .navbar a {
      color: white;
      text-decoration: none;
      margin-left: 20px;
      font-weight: 500;
      transition: color 0.2s;
    }

    .navbar a:hover {
      color: #c7f7e3;
    }

 #searchInput {
      width: 100%;
      max-width: 500px;
      padding: 12px;
      margin-bottom: 25px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }


    .question {
      background-color: #fff;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #007b5e;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    .question button {
      margin-top: 10px;
      background-color: #007b5e;
      color: white;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    .question button:hover {
      background-color: #005f47;
    }

/* Modal Background - covers the full screen */
#whiteboardModal {
  display: none;
  position: fixed;
  inset: 0; /* top:0; right:0; bottom:0; left:0; */
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 9999;
}

/* Modal Content - fits window, scrolls if needed */
.modal-content {
  height: 100vh;       /* fills full viewport */
  width: 100vw;
  background: white;
  margin: 0;
  border-radius: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Modal Header */
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  background-color: #007b5e;
  color: white;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
}

/* Modal Title */
.modal-header h3 {
  margin: 0;
  font-size: 20px;
}

/* Close Button */
.close {
  font-size: 24px;
  cursor: pointer;
}

/* Rendered Math or Question */
#modal-question {
  font-size: 18px;
  padding: 12px 16px;
  background-color: #f9f9f9;
  border-bottom: 1px solid #ccc;
  overflow-x: auto;
}

/* Canvas - Responsive to Modal Height */
canvas {
  flex-grow: 1;
  width: 100%;
  border: 2px solid #ccc;
  border-radius: 8px;
  cursor: crosshair;
}

/* Drawing Tools */
.tools {
  padding: 10px 15px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  border-top: 1px solid #ccc;
  background-color: #38632f;
}

.tools label {
  font-weight: bold;
}

.tools input[type="color"],
.tools input[type="range"] {
  cursor: pointer;
}

.tools button {
  padding: 6px 12px;
  border: none;
  background-color: #f2e6e5;
  color: rgb(17, 12, 12);
  border-radius: 4px;
  cursor: pointer;
}

.tools button:hover {
  background-color: #c0392b;
}

/* Ensure modal remains usable on small screens */
@media (max-width: 768px) {
  .modal-content {
    width: 98%;
    height: 95vh;
  }

  #modal-question {
    font-size: 16px;
  }

  .tools {
    flex-direction: column;
    align-items: flex-start;
  }
}

.canvas-wrapper {
  flex: 1;
  overflow: auto;
  border-top: 1px solid #ccc;
}
  #startBtn, #stopBtn {
    padding: 10px 20px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 8px;
    margin: 10px 8px 0 0;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.2s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }

  #startBtn {
    background-color: #28a745;
    color: white;
  }

  #startBtn:hover {
    background-color: #218838;
    transform: scale(1.05);
  }

  #stopBtn {
    background-color: #dc3545;
    color: white;
  }

  #stopBtn:disabled {
    background-color: #a9a9a9;
    cursor: not-allowed;
  }

  #stopBtn:not(:disabled):hover {
    background-color: #c82333;
    transform: scale(1.05);
  }
          /* Floating Chatbot */
    #chatbot {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 360px;
      max-height: 520px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      z-index: 9999;
      border: 1px solid #ccc;
      font-family: sans-serif;
    }

    #chatbot-header {
      background-color: #007B5E;
      color: white;
      padding: 12px;
      font-weight: bold;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
    }

    .message {
  margin: 8px 0;
  padding: 10px 14px;
  border-radius: 10px;
  max-width: 85%;
  line-height: 1.4;
  word-wrap: break-word;
}

.user-message {
  background-color: #e0f7fa;
  color: #004d40;
  align-self: flex-end;
  text-align: right;
}

.bot-message {
  background-color: #f1f8e9;
  color: #33691e;
  align-self: flex-start;
  text-align: left;
}
#chatlog {
  display: flex;
  flex-direction: column;
}
    #chat-input {
      border: none;
      border-top: 1px solid #ddd;
      padding: 12px;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }

    /* Resize Handle */
#resize-handle {
  width: 16px;
  height: 16px;
  position: absolute;
  right: 0;
  bottom: 0;
  cursor: se-resize;
  background: rgba(0, 0, 0, 0.2);
  z-index: 10;
}


  </style>
</head>
<body>
<!-- Navbar -->
  <div class="navbar">
    <h1>EduPortal</h1>
    <div>
      <a href="{{ url_for('student_dashboard') }}">üè† Home</a>
      <a href="/logout">üö™ Logout</a>
    </div>
  </div>
  <!-- Container -->
  <div class="container">
    <h2>Questions</h2>
    <input type="text" id="searchInput" onkeyup="filterQuestions()" placeholder="üîç Search question...">

<div id="questionList">
  {% for q in questions %}
    <div class="question" data-question="{{ q[1] | escape }}">
      {{ q[1] | safe }}
      <br>
      <button onclick="openWhiteboard(`{{ q[1] | escape | replace('\\', '\\\\') }}`)">üñäÔ∏è Explain</button>
    </div>
  {% endfor %}
</div>

  <!-- Modal with Whiteboard -->
  <div id="whiteboardModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Explain with Whiteboard</h3>
        <div>
          <button id="startBtn">üé¨ Start Recording</button>
          <button id="stopBtn" disabled>‚èπÔ∏è Stop Recording</button>
          </div>
        <div class="tools">
        <label>üñçÔ∏è Pen Color:</label>
        <input type="color" id="penColor" value="#000000">
        <label>‚úèÔ∏è Size:</label>
        <input type="range" id="penSize" min="1" max="10" value="2">
        <button onclick="clearCanvas()">üßΩ Clear</button>
      </div>
        <span class="close" onclick="closeWhiteboard()">‚úñ</span>
      </div>
      <div id="modal-question">Loading question...</div>
      
      <div class="canvas-wrapper">
        <canvas id="whiteboardCanvas" width="4000" height="5000"></canvas>
      </div>
    </div>
  </div>

  <!-- üåü Floating Chatbot -->
<div id="chatbot">
  <div id="chatbot-header">üí¨ Ask AI</div>
  <div id="chatlog" style="padding: 10px; overflow-y: auto;"></div>
  <input id="chat-input" type="text" placeholder="Ask a question..." onkeypress="sendMessage(event)">
  <div id="resize-handle"></div> <!-- ‚¨ÖÔ∏è Resize grip -->
</div>


  <!-- JavaScript -->
  <script>

function filterQuestions() {
      const input = document.getElementById('searchInput').value.toLowerCase();
      const questions = document.querySelectorAll('.question');
      questions.forEach(q => {
        const text = q.dataset.question.toLowerCase();
        q.style.display = text.includes(input) ? "block" : "none";
      });
    }


    const canvas = document.getElementById('whiteboardCanvas');
    const ctx = canvas.getContext('2d');
    const penColor = document.getElementById('penColor');
    const penSize = document.getElementById('penSize');

    let drawing = false;

canvas.addEventListener('mousedown', (e) => {
  drawing = true;
  const rect = canvas.getBoundingClientRect();
  ctx.beginPath();
  ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
});

canvas.addEventListener('mouseup', () => drawing = false);
canvas.addEventListener('mouseout', () => drawing = false);
canvas.addEventListener('mousemove', draw);


function draw(e) {
  if (!drawing) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  ctx.lineWidth = penSize.value;
  ctx.lineCap = 'round';
  ctx.strokeStyle = penColor.value;

  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);
}


    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    }


function sendToChatbot(message) {
  const chatInput = document.getElementById("chat-input");
  chatInput.value = message;

  // Simulate pressing Enter
  const event = new KeyboardEvent("keypress", { key: "Enter", keyCode: 13 });
  chatInput.dispatchEvent(event);
}


function openWhiteboard(latexQuestion) {
  const modal = document.getElementById('whiteboardModal');
  const questionEl = document.getElementById('modal-question');
  questionEl.innerHTML = latexQuestion;

  if (window.MathJax) {
    MathJax.typesetPromise([questionEl]);
  }

  modal.style.display = 'block';
  setTimeout(resizeCanvas, 300);
  clearCanvas();

  // Show the chatbot
  const chatbot = document.getElementById("chatbot");
  chatbot.style.display = "flex";

  // Append question to chatbot and auto-send
  const input = document.getElementById("chat-input");
  input.value = latexQuestion;
  const enterEvent = new KeyboardEvent('keypress', { key: 'Enter' });
  input.dispatchEvent(enterEvent);
}



    function closeWhiteboard() {
      document.getElementById('whiteboardModal').style.display = 'none';
    }

    window.addEventListener('resize', resizeCanvas);

function appendMessage(msg, sender = "bot") {
  const div = document.createElement('div');
  div.classList.add('message');
  div.classList.add(sender === "user" ? 'user-message' : 'bot-message');
  div.textContent = msg;
  document.getElementById('chatlog').appendChild(div);
  document.getElementById('chatlog').scrollTop = document.getElementById('chatlog').scrollHeight;
}

let chatHistory = [];

function sendMessage(e) {
  if (e.key === 'Enter') {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();
    if (!message) return;

    // Append and store user message
    appendMessage("You: " + message, "user");
    chatHistory.push({ role: "user", content: message });

    input.value = '...'; // Show loading

    fetch('/ask', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ history: chatHistory })  // Send full history
    })
    .then(res => res.json())
    .then(data => {
      const botReply = data.reply || "‚ö†Ô∏è No reply.";
      appendMessage("Experts: " + botReply, "bot");

      // Store Gemini's reply in history
      chatHistory.push({ role: "assistant", content: botReply });

      // Ask MathJax to re-typeset any LaTeX
      if (window.MathJax) {
        MathJax.typeset();
      }

      input.value = '';
    })
    .catch(() => {
      appendMessage("‚ùå Error contacting Gemini.", "bot");
      input.value = '';
    });
  }
}

  const chatbot = document.getElementById('chatbot');
  const handle = document.getElementById('resize-handle');

  let isResizing = false;

  handle.addEventListener('mousedown', function(e) {
    e.preventDefault();
    isResizing = true;
    document.body.style.userSelect = 'none';
  });

  document.addEventListener('mousemove', function(e) {
    if (!isResizing) return;

    const minWidth = 250;
    const minHeight = 300;

    const rect = chatbot.getBoundingClientRect();
    const newWidth = Math.max(minWidth, e.clientX - rect.left);
    const newHeight = Math.max(minHeight, e.clientY - rect.top);

    chatbot.style.width = newWidth + 'px';
    chatbot.style.height = newHeight + 'px';
  });

  document.addEventListener('mouseup', function() {
    isResizing = false;
    document.body.style.userSelect = 'auto';
  });



 
let mediaRecorder;
let recordedChunks = [];
let screenStream;

const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");

startBtn.onclick = async () => {
  try {
    // Capture screen with system audio
    const screen = await navigator.mediaDevices.getDisplayMedia({
      video: true,
      audio: true // May or may not include system audio
    });

    // Capture microphone audio separately
    const mic = await navigator.mediaDevices.getUserMedia({
      audio: true
    });

    // Combine audio tracks
    const combinedStream = new MediaStream([
      ...screen.getVideoTracks(),
      ...screen.getAudioTracks(),
      ...mic.getAudioTracks()
    ]);

    recordedChunks = [];
    mediaRecorder = new MediaRecorder(combinedStream);

    mediaRecorder.ondataavailable = event => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
      }
    };

    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);

      // Auto-download
      const a = document.createElement("a");
      a.href = url;
      a.download = `recording-${Date.now()}.webm`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    mediaRecorder.start();
    screenStream = combinedStream;
    startBtn.disabled = true;
    stopBtn.disabled = false;
  } catch (err) {
    alert("Error starting screen recording: " + err.message);
    console.error(err);
  }
};

stopBtn.onclick = () => {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
    screenStream.getTracks().forEach(track => track.stop());

    startBtn.disabled = false;
    stopBtn.disabled = true;
  }
};

  </script>
</body>
</html>

